[{"title":"Introduction","type":0,"sectionRef":"#","url":"/iter/docs/intro","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#installation","content":""},{"title":"Wally​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#wally","content":"Add the latest version of iter to your wally.toml: iter = &quot;chriscerie/iter@&lt;version&gt;&quot;  "},{"title":"Goals​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#goals","content":""},{"title":"Composable​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#composable","content":"Chaining operations and transformations in one operation makes the flow of complex data structures very predictable and easy to read. It's much more intuitive to transformations being applied to data as isolated layers than series of loops. "},{"title":"Immutable​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#immutable","content":"By default, tables returned by iter are frozen. This is a good thing! Mutating data structures when you don't expect it is a major source of bugs in software. Instead, when a table returned by iter needs to be directly modifiable, you must be explicit about it. "},{"title":"Example​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#example","content":"As a basic example, imagine you have a dictionary of scores local values = { player1 = 321, player2 = 521, player3 = 232, ... }  And you want to transform the scores into an array for further processing. However you want to stop at the first score above 500 that you see. Then you want to count the number of scores that aren't part of the array. "},{"title":"Without iter​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#without-iter","content":"Without iter, we can move the values into an array while keeping track of the checked values. Then we can calculate the total number of values to begin with, and get the number of scores that are left by subtracting the two values. local checkedValues = {} local countChecked = 0 for _, value in values do countChecked += 1 if value &gt; 500 then break end table.insert(checkedValues, value) end local countTotal = 0 for _, value in values do countTotal += 1 end print(checkedValues) print(countTotal - countChecked)  "},{"title":"With iter​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#with-iter","content":"With iter, this becomes easier. We can use mapWhile to keep the values until we see a score above 500, then collect the values as an array. As an aside, if we wanted to preserve the dictionary and collect the values as key-value pairs, we can just call :collect() instead to preserve the original data structure. Then counting the rest of the values is easy. We can simply call :count() to grab the count of the remaining values. local iterator = iter.new(a) local checkedValues = iterator :mapWhile(function(_key, value) return if value &gt; 500 then nil else value end) :collectArray() print(checkedValues) print(iterator:count())  "},{"title":"Next Steps​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#next-steps","content":"Check out the API Reference "},{"title":"Lazy evaluation","type":0,"sectionRef":"#","url":"/iter/docs/lazy","content":"Lazy evaluation Iterators are lazy, meaning they don't do any processing work until you need them. This code won't run because map by itself doesn't do anything, because the would-be result is never used. iter.new(t):map(function(_, value: number) -- This never runs return value * 2 end) Iterators only run when they are needed and consumed. There's several ways to consume iterators. One of the most common ways is to grab the resulting table with collect. iter.new(t) :map(function(_, value: number) -- Now this runs return value * 2 end) :collect() This mechanism enables iter to perform aggressive optimizations when it can. Imagine you want to apply some expensive transformation function to an array, but you only want to get the first 40 elements. iter will see that you don't need the entire array to be transformed, so it will stop at the first 40. If the original array is some extreme size, it's that many iterations that iter avoids. iter.new(t) :map(function(_, value: number) -- Only runs 40 times even if array is much larger return someExpensiveFn(value) end) :take(40) :collect() While this short circuiting behavior can also be implemented in traditional loops (use a counter and break out of the loop after 40 iterations), it requires the consuming logic to be next to the transformation logic. Imagine you own a table, want to apply some transformation to it, then pass it off to another part of the code to ultimately consume. Many times you don't have any information on how the table will eventually get used - the downstream consumer can read the entire table, just the first few elements, or even just check if a condition holds true (like if any elements is even). In these cases, traditional loops would require you to apply the transformation function for the entire table, no matter how much of the table the consumer needs. Instead, with iter we can queue transformations, but they won't take effect immediately. We can then pass the entire iterator to the consumer and iter will make any optimizations as necessary when it ultimately gets consumed.","keywords":""},{"title":"iter","type":0,"sectionRef":"#","url":"/iter/api/iter","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"iter","url":"/iter/api/iter#functions","content":" "},{"title":"new​","type":1,"pageTitle":"iter","url":"/iter/api/iter#new","content":"&lt;/&gt; iter.new(value: {[any]: any}) → iter Constructs new iter  "},{"title":"all​","type":1,"pageTitle":"iter","url":"/iter/api/iter#all","content":"&lt;/&gt; iter:all(f: (...any) → boolean) → boolean Tests if every element of the iterator matches a predicate. all() takes a closure that returns true or false. It applies this closure to each element of the iterator, and if they all return true, then so does all(). If any of them return false, it returns false. all() is short-circuiting; in other words, it will stop processing as soon as it finds a false, given that no matter what else happens, the result will also be false. An empty iterator returns true. Examples Basic usage: local a = {1, 2, 3} assert(iter(a):all(function(_, x) return x &gt; 0 end)) assert(not iter(a):all(function(_, x) return x &gt; 2 end)) Stopping at the first false: local a = {1, 2, 3} local iterator = iter(a) assert(not iterator:all(function(_, x) return x ~= 2 end)) -- we can still use `iter`, as there are more elements. assert(next(iterator) == 3)   "},{"title":"asMut​","type":1,"pageTitle":"iter","url":"/iter/api/iter#asMut","content":"&lt;/&gt; iter:asMut() → iter Ensures table.freeze doesn't get called when iterator gets collected. Deviations In Rust this is done by specifying mut to the assigning variable, but this is not a feature in Lua.  "},{"title":"any​","type":1,"pageTitle":"iter","url":"/iter/api/iter#any","content":"&lt;/&gt; iter:any(f: (...any) → boolean) → boolean Tests if any element of the iterator matches a predicate. any() takes a function that returns true or false. It applies this function to each element of the iterator, and if any of them return true, then so does any(). If they all return false, it returns false. any() is short-circuiting; in other words, it will stop processing as soon as it finds a true, given that no matter what else happens, the result will also be true. An empty iterator returns false. Examples Basic usage: local a = {1, 2, 3} assert(iter(a):all(function(_, x) return x &gt; 0 end)) assert(not iter(a):all(function(_, x) return x &gt; 5 end)) Stopping at the first true: local a = {1, 2, 3} local iterator = iter(a) assert(not iterator:all(function(_, x) return x ~= 2 end)) -- we can still use `iter`, as there are more elements. assert(next(iterator) == 2)   "},{"title":"count​","type":1,"pageTitle":"iter","url":"/iter/api/iter#count","content":"&lt;/&gt; iter:count() → number Consumes the iterator, counting the number of iterations and returning it. This method will call [next] repeatedly until nil is encountered, returning the number of times it saw values. Note that [next] has to be called at least once even if the iterator does not have any elements.  "},{"title":"collect​","type":1,"pageTitle":"iter","url":"/iter/api/iter#collect","content":"&lt;/&gt; iter:collect() → {[any]: any} Transforms an iterator into a table. collect() can take anything iterable, and turn it into a relevant table. This is one of the more powerful methods in the standard library, used in a variety of contexts. The most basic pattern in which collect() is used is to turn one table into another. You take a table, call [iter] on it, do a bunch of transformations, and then collect() at the end. Deviations The returned table is frozen by default if [asMut] was never called.  "},{"title":"collectArray​","type":1,"pageTitle":"iter","url":"/iter/api/iter#collectArray","content":"&lt;/&gt; iter:collectArray() → {any} Same thing as [collect], but turns table into arrays of its values and discards its keys. Deviations In Rust this would be done by using [collect] and specifying the type, but types in lua do not affect the runtime. The returned table is frozen by default if [asMut] was never called.  "},{"title":"filter​","type":1,"pageTitle":"iter","url":"/iter/api/iter#filter","content":"&lt;/&gt; iter:filter(predicate: ( any, any ) → boolean) → iter Creates an iterator which uses a closure to determine if an element should be yielded. Given an element the closure must return true or false. The returned iterator will yield only the elements for which the closure returns true.  "},{"title":"filterMap​","type":1,"pageTitle":"iter","url":"/iter/api/iter#filterMap","content":"&lt;/&gt; iter:filterMap(f: ( any, any ) → any?) → () Creates an iterator that both filters and maps. The returned iterator yields only the values for which the supplied closure returns non-nil. filterMap can be used to make chains of [filter] and [map] more concise. Examples Basic usage: local a = {&quot;1&quot;, &quot;two&quot;, &quot;hi&quot;, &quot;four&quot;, &quot;5&quot;} local iterator = iter.new(a):filterMap(function(s) return tonumber(a) end) iterator:next() -&gt; 1, 1 iterator.next() -&gt; 1, 5 iterator.next() -&gt; iter.None Deviations filterMap will assume arrays the table is an array and will slide entries down if values are removed as long as the table is contiguous. The first time a non-array key is encountered (key that jumps or non-numeric key), filterMap will act the same as map.  "},{"title":"find​","type":1,"pageTitle":"iter","url":"/iter/api/iter#find","content":"&lt;/&gt; iter:find(predicate: ( any, any ) → boolean) → ...any? Searches for an element of an iterator that satisfies a predicate. find() takes a closure that returns true or false. It applies this closure to each element of the iterator, and if any of them return true, then find() returns the element. If they all return false, it returns None. find() is short-circuiting; in other words, it will stop processing as soon as the closure returns true  "},{"title":"findMap​","type":1,"pageTitle":"iter","url":"/iter/api/iter#findMap","content":"&lt;/&gt; iter:findMap(f: ( any, any ) → any) → () Applies function to the elements of iterator and returns the first non-nil result. iter:findMap(f) is equivalent to iter:filterMap(f):next(). Examples local a = {&quot;lol&quot;, &quot;hi&quot;, &quot;2&quot;, &quot;5&quot;} local _, firstNumber = iter.new(a):findMap(function(_k, s) return tonumber(s) end) assert(firstNumber == 2)   "},{"title":"fold​","type":1,"pageTitle":"iter","url":"/iter/api/iter#fold","content":"&lt;/&gt; iter:fold( init: T, f: ( T, ...any ) → T ) → T Folds every element into an accumulator by applying an operation, returning the final result. fold() takes two arguments: an initial value, and a closure with two arguments: an 'accumulator', and an element. The closure returns the value that the accumulator should have for the next iteration. The initial value is the value the accumulator will have on the first call. After applying this closure to every element of the iterator, fold() returns the accumulator. This operation is sometimes called 'reduce' or 'inject'. Folding is useful whenever you have a collection of something, and want to produce a single value from it. Errors If the iterator is an infinite iterator (DEVIATION) Examples Basic usage: local a = {1, 2, 3} -- the sum of all of the elements of the array local sum = iter.new(a):fold(0, function(acc, x) return acc + x end) assert(sum == 6) This example demonstrates the left-associative nature of fold(): it builds a string, starting with an initial value and continuing with each element from the front until the back: local numbers = {1, 2, 3, 4, 5} local result = iter.new(numbers):fold(&quot;0&quot;, function(acc, x) return `({acc} + {x})` end); assert(result, &quot;(((((0 + 1) + 2) + 3) + 4) + 5)&quot;);   "},{"title":"forEach​","type":1,"pageTitle":"iter","url":"/iter/api/iter#forEach","content":"&lt;/&gt; iter:forEach(f: (...any) → ()) → () Calls a closure on each element of an iterator. This is equivalent to using a for loop on the iterator, although break and continue are not possible from a closure. It's generally more idiomatic to use a for loop, but for_each may be more legible when processing items at the end of longer iterator chains. Examples Basic usage: iter.new({ 0, 1, 2 }) :map(function(_, x: number) return x * 100 end) :filter(function(i: number, x: number) return (i + x) % 3 == 0 end) :for_each(function(i: number, x: number) print(`{i}:{x}`) end)   "},{"title":"inspect​","type":1,"pageTitle":"iter","url":"/iter/api/iter#inspect","content":"&lt;/&gt; iter:inspect(f: (...any) → ()) → () Does something with each element of an iterator, passing the value on. When using iterators, you'll often chain several of them together. While working on such code, you might want to check out what's happening at various parts in the pipeline. To do that, insert a call to inspect(). It's more common for inspect() to be used as a debugging tool than to exist in your final code, but applications may find it useful in certain situations when errors need to be logged before being discarded. Examples Basic usage: local a = {1, 4, 2, 3} -- this iterator sequence is complex. local sum = iter.new(a) :cloned() :filter(function(x) return x % 2 == 0 end) :fold(0, function(sum, i) return sum + i end) print(&quot;{sum}&quot;) -- let's add some inspect() calls to investigate what's happening let sum = a.iter() :inspect(function(x) print(&quot;about to filter: {x}&quot;) end) :filter(function(x) return x % 2 == 0 end) :inspect(function(x) print(&quot;made it through filter: {x}&quot;) end) :fold(0, function(sum, i) return sum + i end) print(`{sum}`) This will print: 6 about to filter: 1 about to filter: 4 made it through filter: 4 about to filter: 2 made it through filter: 2 about to filter: 3 6   "},{"title":"last​","type":1,"pageTitle":"iter","url":"/iter/api/iter#last","content":"&lt;/&gt; iter:last() → ...any Consumes the iterator, returning the last element. For non-arrays, this method will evaluate the iterator until it returns nil. While doing so, it keeps track of the current element. After nil is returned, last() will then return the last element it saw. Examples Basic usage: local a = {1, 2, 3} assert(iter.new(a).last() == 3) local a = {1, 2, 3, 4, 5} assert(iter.new(a).last() == 5)   "},{"title":"map​","type":1,"pageTitle":"iter","url":"/iter/api/iter#map","content":"&lt;/&gt; iter:map(f: (...any) → ...any) → iter Takes a closure and creates an iterator which calls that closure on each element. map() transforms one iterator into another. It produces a new iterator which calls this closure on each element of the original iterator. If you are good at thinking in types, you can think of map() like this: If you have an iterator that gives you elements of some type A, and you want an iterator of some other type B, you can use map(), passing a closure that takes an A and returns a B. map() is conceptually similar to a for loop. If you're doing some sort of looping for a side effect, it's considered more idiomatic to use for than map().  "},{"title":"mapWhile​","type":1,"pageTitle":"iter","url":"/iter/api/iter#mapWhile","content":"&lt;/&gt; iter:mapWhile(predicate: (...any) → ...any) → iter Creates an iterator that both yields elements based on a predicate and maps. mapWhile() takes a function as an argument. It will call this function on each element of the iterator, and yield elements while it returns non-nil.  "},{"title":"next​","type":1,"pageTitle":"iter","url":"/iter/api/iter#next","content":"&lt;/&gt; iter:next() → any Advances the iterator and returns the next value. Returns nil when iteration is finished. Examples Basic usage: local a = {1, 2, 3} local iterator = iter.new(a) -- A call to next() returns the next value... assert(1 == iter.next()) assert(2 == iter.next()) assert(3 == iter.next()) -- ... and then `nil` once it's over. assert(nil == iter.next())   "},{"title":"reduce​","type":1,"pageTitle":"iter","url":"/iter/api/iter#reduce","content":"&lt;/&gt; iter:reduce(f: ( any, any ) → any) → any Reduces the elements to a single one, by repeatedly applying a reducing operation. If the iterator is empty, returns iter.None; otherwise, returns the result of the reduction. The reducing function is a closure with two arguments: an 'accumulator', and an element.For iterators with at least one element, this is the same as [fold] with the first element of the iterator as the initial accumulator value, folding every subsequent element into it. Example local a = { 1, 2, ..., 10 } local reduced = iter.new(a):reduce(function(acc, e) return acc + e end) assert(reduced == 45) -- Which is equivalent to doing it with `fold`: local folded = iter.new(a):fold(0, function(acc, e) return acc + e end) assert(reduced == folded)   "},{"title":"take​","type":1,"pageTitle":"iter","url":"/iter/api/iter#take","content":"&lt;/&gt; iter:take(n: number) → () Creates an iterator that yields the first n elements, or fewer if the underlying iterator ends sooner. take(n) yields elements until n elements are yielded or the end of the iterator is reached (whichever happens first). The returned iterator is a prefix of length n if the original iterator contains at least n elements, otherwise it contains all of the (fewer than n) elements of the original iterator.  "},{"title":"tryFold​","type":1,"pageTitle":"iter","url":"/iter/api/iter#tryFold","content":"&lt;/&gt; iter:tryFold( init: T, f: ( T, ...any ) → T? ) → T? An iterator method that applies a function as long as it returns successfully, producing a single, final value. tryFold() takes two arguments: an initial value, and a closure with two arguments: an 'accumulator', and an element. The closure either returns successfully, with the value that the accumulator should have for the next iteration, or it returns nil that is propagated back to the caller immediately (short-circuiting). The initial value is the value the accumulator will have on the first call. If applying the closure succeeded against every element of the iterator, tryFold() returns the final accumulator as success. Folding is useful whenever you have a collection of something, and want to produce a single value from it. "}]