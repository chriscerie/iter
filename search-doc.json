[{"title":"iter","type":0,"sectionRef":"#","url":"/iter/api/iter","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"iter","url":"/iter/api/iter#functions","content":" "},{"title":"all​","type":1,"pageTitle":"iter","url":"/iter/api/iter#all","content":"&lt;/&gt; iter:all(predicate: (...any) → boolean) → () Tests if every element of the iterator matches a predicate. all() takes a closure that returns true or false. It applies this closure to each element of the iterator, and if they all return true, then so does all(). If any of them return false, it returns false. all() is short-circuiting; in other words, it will stop processing as soon as it finds a false, given that no matter what else happens, the result will also be false. An empty iterator returns true. Examples Basic usage: local a = {1, 2, 3} assert(iter(a):all(function(x) return x &gt; 0 end)) assert(not iter(a):all(function(x) return x &gt; 2 end)) Stopping at the first false: local a = {1, 2, 3} local iterator = iter(a) assert(not iterator:all(function(x) return x ~= 2 end)) -- we can still use `iter`, as there are more elements. assert(next(iterator) == 3)   "},{"title":"any​","type":1,"pageTitle":"iter","url":"/iter/api/iter#any","content":"&lt;/&gt; iter:any(predicate: (...any) → boolean) → () Tests if any element of the iterator matches a predicate. any() takes a function that returns true or false. It applies this function to each element of the iterator, and if any of them return true, then so does any(). If they all return false, it returns false. any() is short-circuiting; in other words, it will stop processing as soon as it finds a true, given that no matter what else happens, the result will also be true. An empty iterator returns false. Examples Basic usage: local a = {1, 2, 3} assert(iter(a):all(function(x) return x &gt; 0 end)) assert(not iter(a):all(function(x) return x &gt; 5 end)) Stopping at the first true: local a = {1, 2, 3} local iterator = iter(a) assert(not iterator:all(function(x) return x ~= 2 end)) -- we can still use `iter`, as there are more elements. assert(next(iterator) == 2)   "},{"title":"count​","type":1,"pageTitle":"iter","url":"/iter/api/iter#count","content":"&lt;/&gt; iter:count() → () Consumes the iterator, counting the number of iterations and returning it. This method will call [next] repeatedly until nil is encountered, returning the number of times it saw values. Note that [next] has to be called at least once even if the iterator does not have any elements.  "},{"title":"collect​","type":1,"pageTitle":"iter","url":"/iter/api/iter#collect","content":"&lt;/&gt; iter:collect() → () Transforms an iterator into a table. collect() can take anything iterable, and turn it into a relevant table. This is one of the more powerful methods in the standard library, used in a variety of contexts. The most basic pattern in which collect() is used is to turn one table into another. You take a table, call [iter] on it, do a bunch of transformations, and then collect() at the end.  "},{"title":"enumerate​","type":1,"pageTitle":"iter","url":"/iter/api/iter#enumerate","content":"&lt;/&gt; iter:enumerate() → () Creates an iterator which gives the current iteration count as well as the next value. The iterator returned yields pairs (i, val) for arrays and (i, key, val) for dicts, where i is the current index of iteration. Examples local a = {'a', 'b', 'c'} local iterator = array(a).enumerate() print(iterator:next()) -&gt; 1, &quot;a&quot; print(iterator:next()) -&gt; 2, &quot;b&quot; print(iterator:next()) -&gt; 3, &quot;c&quot; print(iterator:next()) -&gt; nil local b = { akey = 'a', bkey = 'b', ckey = 'c', } iterator = dict(b).enumerate() print(iterator:next()) -&gt; 1, &quot;akey&quot;, &quot;a&quot; print(iterator:next()) -&gt; 2, &quot;bkey&quot;, &quot;b&quot; print(iterator:next()) -&gt; 3, &quot;ckey&quot;, &quot;c&quot; print(iterator:next()) -&gt; nil Deviations For dicts, the iterator returned yields tuples (i, key, val) Indexing starts at 1  "},{"title":"last​","type":1,"pageTitle":"iter","url":"/iter/api/iter#last","content":"&lt;/&gt; iter:last() → any Consumes the iterator, returning the last element. For non-arrays, this method will evaluate the iterator until it returns nil. While doing so, it keeps track of the current element. After nil is returned, last() will then return the last element it saw. Examples Basic usage: local a = {1, 2, 3}; assert(array(a).last() == 3); local a = {1, 2, 3, 4, 5}; assert(array(a).last() == 5);   "},{"title":"mapWhile​","type":1,"pageTitle":"iter","url":"/iter/api/iter#mapWhile","content":"&lt;/&gt; iter:mapWhile(transformer: (...any) → any) → () Creates an iterator that both yields elements based on a predicate and maps. mapWhile() takes a function as an argument. It will call this function on each element of the iterator, and yield elements while it returns non-nil.  "},{"title":"filter​","type":1,"pageTitle":"iter","url":"/iter/api/iter#filter","content":"&lt;/&gt; iter:filter(predicate: ( any, any ) → boolean) → () Creates an iterator which uses a closure to determine if an element should be yielded. Given an element the closure must return true or false. The returned iterator will yield only the elements for which the closure returns true.  "},{"title":"forEach​","type":1,"pageTitle":"iter","url":"/iter/api/iter#forEach","content":"&lt;/&gt; iter:forEach(f: (...any) → ()) → () Calls a closure on each element of an iterator. This is equivalent to using a for loop on the iterator, although break and continue are not possible from a closure. It's generally more idiomatic to use a for loop, but for_each may be more legible when processing items at the end of longer iterator chains. #Examples Basic usage: tb.array({ 0, 1, 2 }) :map(function(x: number) return x * 100 end) :enumerate() :filter(function(i: number, x: number) return (i + x) % 3 == 0 end) :for_each(function(i: number, x: number) print(`{i}:{x}`) end)  "}]