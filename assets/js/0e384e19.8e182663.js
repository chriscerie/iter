"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[671],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=u(a),m=r,h=p["".concat(s,".").concat(m)]||p[m]||d[m]||o;return a?n.createElement(h,l(l({ref:t},c),{},{components:a})):n.createElement(h,l({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[p]="string"==typeof e?e:r,l[1]=i;for(var u=2;u<o;u++)l[u]=a[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},59881:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>u});var n=a(87462),r=(a(67294),a(3905));const o={sidebar_position:1},l="Introduction",i={unversionedId:"intro",id:"intro",title:"Introduction",description:"iter is a composable immutable table library for Lua based on Rust's iterators. It makes complex data manipulations a breeze.",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/iter/docs/intro",draft:!1,editUrl:"https://github.com/chriscerie/iter/edit/main/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"defaultSidebar",next:{title:"Lazy evaluation",permalink:"/iter/docs/lazy"}},s={},u=[{value:"Installation",id:"installation",level:2},{value:"Wally",id:"wally",level:3},{value:"Goals",id:"goals",level:2},{value:"Composable",id:"composable",level:3},{value:"Immutable",id:"immutable",level:3},{value:"Example",id:"example",level:2},{value:"Without iter",id:"without-iter",level:3},{value:"With iter",id:"with-iter",level:3},{value:"Next Steps",id:"next-steps",level:2}],c={toc:u},p="wrapper";function d(e){let{components:t,...a}=e;return(0,r.kt)(p,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"iter")," is a composable immutable table library for Lua based on Rust's iterators. It makes complex data manipulations a breeze."),(0,r.kt)("h2",{id:"installation"},"Installation"),(0,r.kt)("h3",{id:"wally"},"Wally"),(0,r.kt)("p",null,"Add the latest version of iter to your ",(0,r.kt)("inlineCode",{parentName:"p"},"wally.toml"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},'iter = "chriscerie/iter@<version>"\n')),(0,r.kt)("h2",{id:"goals"},"Goals"),(0,r.kt)("h3",{id:"composable"},"Composable"),(0,r.kt)("p",null,"Chaining operations and transformations in one operation makes the flow of complex data structures very predictable and easy to read. It's much more intuitive to transformations being applied to data as isolated layers than series of loops."),(0,r.kt)("h3",{id:"immutable"},"Immutable"),(0,r.kt)("p",null,"By default, tables returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"iter")," are frozen. This is a good thing! Mutating data structures when you don't expect it is a major source of bugs in software. Instead, when a table returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"iter")," needs to be directly modifiable, you must be ",(0,r.kt)("a",{parentName:"p",href:"/iter/api/iter#asMut"},"explicit")," about it."),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"As a basic example, imagine you have a dictionary of scores"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local values = {\n    player1 = 321,\n    player2 = 521,\n    player3 = 232,\n    ...\n}\n")),(0,r.kt)("p",null,"And you want to transform the scores into an array for further processing. However you want to stop at the first score above 500 that you see. Then you want to count the number of scores that aren't part of the array."),(0,r.kt)("h3",{id:"without-iter"},"Without iter"),(0,r.kt)("p",null,"Without iter, we can move the values into an array while keeping track of the checked values. Then we can calculate the total number of values to begin with, and get the number of scores that are left by subtracting the two values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local checkedValues = {}\nlocal countChecked = 0\nfor _, value in values do\n    countChecked += 1\n    if value > 500 then\n        break\n    end\n\n    table.insert(checkedValues, value)\nend\n\nlocal countTotal = 0\nfor _, value in values do\n    countTotal += 1\nend\n\nprint(checkedValues)\nprint(countTotal - countChecked)\n")),(0,r.kt)("h3",{id:"with-iter"},"With iter"),(0,r.kt)("p",null,"With iter, this becomes easier. We can use ",(0,r.kt)("inlineCode",{parentName:"p"},"mapWhile")," to keep the values until we see a score above 500, then collect the values as an array. As an aside, if we wanted to preserve the dictionary and collect the values as key-value pairs, we can just call ",(0,r.kt)("inlineCode",{parentName:"p"},":collect()")," instead to preserve the original data structure."),(0,r.kt)("p",null,"Then counting the rest of the values is easy. We can simply call ",(0,r.kt)("inlineCode",{parentName:"p"},":count()")," to grab the count of the remaining values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local iterator = iter.dict(a)\nlocal checkedValues = iterator\n    :mapWhile(function(_key, value)\n        return if value > 500 then nil else value\n    end)\n    :collectArray()\n\nprint(checkedValues)\nprint(iterator:count())\n")),(0,r.kt)("h2",{id:"next-steps"},"Next Steps"),(0,r.kt)("p",null,"Check out the ",(0,r.kt)("a",{parentName:"p",href:"/iter/api"},"API Reference")))}d.isMDXComponent=!0}}]);