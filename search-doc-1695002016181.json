[{"title":"Introduction","type":0,"sectionRef":"#","url":"/iter/docs/intro","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#installation","content":""},{"title":"Wally​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#wally","content":"Add the latest version of iter to your wally.toml: iter = &quot;chriscerie/iter@&lt;version&gt;&quot;  "},{"title":"Goals​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#goals","content":""},{"title":"Composable​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#composable","content":"Chaining operations and transformations in one operation makes the flow of complex data structures very predictable and easy to read. It's much more intuitive to transformations being applied to data as isolated layers than series of loops. "},{"title":"Immutable​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#immutable","content":"By default, tables returned by iter are frozen. This is a good thing! Mutating data structures when you don't expect it is a major source of bugs in software. Instead, when a table returned by iter needs to be directly modifiable, you must be explicit about it. "},{"title":"Example​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#example","content":"As a basic example, imagine you have a dictionary of scores local values = { player1 = 321, player2 = 521, player3 = 232, ... }  And you want to transform the scores into an array for further processing. However you want to stop at the first score above 500 that you see. Then you want to count the number of scores that aren't part of the array. "},{"title":"Without iter​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#without-iter","content":"Without iter, we can move the values into an array while keeping track of the checked values. Then we can calculate the total number of values to begin with, and get the number of scores that are left by subtracting the two values. local checkedValues = {} local countChecked = 0 for _, value in values do countChecked += 1 if value &gt; 500 then break end table.insert(checkedValues, value) end local countTotal = 0 for _, value in values do countTotal += 1 end print(checkedValues) print(countTotal - countChecked)  "},{"title":"With iter​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#with-iter","content":"With iter, this becomes easier. We can use mapWhile to keep the values until we see a score above 500, then collect the values as an array. As an aside, if we wanted to preserve the dictionary and collect the values as key-value pairs, we can just call :collect() instead to preserve the original data structure. Then counting the rest of the values is easy. We can simply call :count() to grab the count of the remaining values. local iterator = iter.dict(a) local checkedValues = iterator :mapWhile(function(_key, value) return if value &gt; 500 then nil else value end) :collectArray() print(checkedValues) print(iterator:count())  "},{"title":"Next Steps​","type":1,"pageTitle":"Introduction","url":"/iter/docs/intro#next-steps","content":"Check out the API Reference "},{"title":"iter","type":0,"sectionRef":"#","url":"/iter/api/iter","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"iter","url":"/iter/api/iter#functions","content":" "},{"title":"all​","type":1,"pageTitle":"iter","url":"/iter/api/iter#all","content":"&lt;/&gt; iter:all(predicate: (...any) → boolean) → boolean Tests if every element of the iterator matches a predicate. all() takes a closure that returns true or false. It applies this closure to each element of the iterator, and if they all return true, then so does all(). If any of them return false, it returns false. all() is short-circuiting; in other words, it will stop processing as soon as it finds a false, given that no matter what else happens, the result will also be false. An empty iterator returns true. Examples Basic usage: local a = {1, 2, 3} assert(iter(a):all(function(x) return x &gt; 0 end)) assert(not iter(a):all(function(x) return x &gt; 2 end)) Stopping at the first false: local a = {1, 2, 3} local iterator = iter(a) assert(not iterator:all(function(x) return x ~= 2 end)) -- we can still use `iter`, as there are more elements. assert(next(iterator) == 3)   "},{"title":"asMut​","type":1,"pageTitle":"iter","url":"/iter/api/iter#asMut","content":"&lt;/&gt; iter:asMut() → iter Ensures table.freeze doesn't get called when iterator gets collected. Deviations In Rust this is done by specifying mut to the assigning variable, but this is not a feature in Lua.  "},{"title":"any​","type":1,"pageTitle":"iter","url":"/iter/api/iter#any","content":"&lt;/&gt; iter:any(predicate: (...any) → boolean) → boolean Tests if any element of the iterator matches a predicate. any() takes a function that returns true or false. It applies this function to each element of the iterator, and if any of them return true, then so does any(). If they all return false, it returns false. any() is short-circuiting; in other words, it will stop processing as soon as it finds a true, given that no matter what else happens, the result will also be true. An empty iterator returns false. Examples Basic usage: local a = {1, 2, 3} assert(iter(a):all(function(x) return x &gt; 0 end)) assert(not iter(a):all(function(x) return x &gt; 5 end)) Stopping at the first true: local a = {1, 2, 3} local iterator = iter(a) assert(not iterator:all(function(x) return x ~= 2 end)) -- we can still use `iter`, as there are more elements. assert(next(iterator) == 2)   "},{"title":"count​","type":1,"pageTitle":"iter","url":"/iter/api/iter#count","content":"&lt;/&gt; iter:count() → number Consumes the iterator, counting the number of iterations and returning it. This method will call [next] repeatedly until nil is encountered, returning the number of times it saw values. Note that [next] has to be called at least once even if the iterator does not have any elements.  "},{"title":"collect​","type":1,"pageTitle":"iter","url":"/iter/api/iter#collect","content":"&lt;/&gt; iter:collect() → {[any]: any} Transforms an iterator into a table. collect() can take anything iterable, and turn it into a relevant table. This is one of the more powerful methods in the standard library, used in a variety of contexts. The most basic pattern in which collect() is used is to turn one table into another. You take a table, call [iter] on it, do a bunch of transformations, and then collect() at the end. Deviations The returned table is frozen by default if [asMut] was never called.  "},{"title":"collectArray​","type":1,"pageTitle":"iter","url":"/iter/api/iter#collectArray","content":"&lt;/&gt; iter:collectArray() → {any} Same thing as [collect], but turns table into arrays of its values and discards its keys. Deviations In Rust this would be done by using [collect] and specifying the type, but types in lua do not affect the runtime. The returned table is frozen by default if [asMut] was never called.  "},{"title":"enumerate​","type":1,"pageTitle":"iter","url":"/iter/api/iter#enumerate","content":"&lt;/&gt; iter:enumerate() → iter Creates an iterator which gives the current iteration count as well as the next value. The iterator returned yields pairs (i, val) for arrays and (i, key, val) for dicts, where i is the current index of iteration. Examples local a = {'a', 'b', 'c'} local iterator = array(a).enumerate() print(iterator:next()) -&gt; 1, &quot;a&quot; print(iterator:next()) -&gt; 2, &quot;b&quot; print(iterator:next()) -&gt; 3, &quot;c&quot; print(iterator:next()) -&gt; nil local b = { akey = 'a', bkey = 'b', ckey = 'c', } iterator = dict(b).enumerate() print(iterator:next()) -&gt; 1, &quot;akey&quot;, &quot;a&quot; print(iterator:next()) -&gt; 2, &quot;bkey&quot;, &quot;b&quot; print(iterator:next()) -&gt; 3, &quot;ckey&quot;, &quot;c&quot; print(iterator:next()) -&gt; nil Deviations For dicts, the iterator returned yields tuples (i, key, val) Indexing starts at 1  "},{"title":"last​","type":1,"pageTitle":"iter","url":"/iter/api/iter#last","content":"&lt;/&gt; iter:last() → any Consumes the iterator, returning the last element. For non-arrays, this method will evaluate the iterator until it returns nil. While doing so, it keeps track of the current element. After nil is returned, last() will then return the last element it saw. Examples Basic usage: local a = {1, 2, 3} assert(array(a).last() == 3) local a = {1, 2, 3, 4, 5} assert(array(a).last() == 5)   "},{"title":"map​","type":1,"pageTitle":"iter","url":"/iter/api/iter#map","content":"&lt;/&gt; iter:map(transformer: (...any) → any) → iter Takes a closure and creates an iterator which calls that closure on each element. map() transforms one iterator into another. It produces a new iterator which calls this closure on each element of the original iterator. If you are good at thinking in types, you can think of map() like this: If you have an iterator that gives you elements of some type A, and you want an iterator of some other type B, you can use map(), passing a closure that takes an A and returns a B. map() is conceptually similar to a for loop. If you're doing some sort of looping for a side effect, it's considered more idiomatic to use for than map().  "},{"title":"mapWhile​","type":1,"pageTitle":"iter","url":"/iter/api/iter#mapWhile","content":"&lt;/&gt; iter:mapWhile(transformer: (...any) → any) → iter Creates an iterator that both yields elements based on a predicate and maps. mapWhile() takes a function as an argument. It will call this function on each element of the iterator, and yield elements while it returns non-nil.  "},{"title":"next​","type":1,"pageTitle":"iter","url":"/iter/api/iter#next","content":"&lt;/&gt; iter:next() → any Advances the iterator and returns the next value. Returns nil when iteration is finished. Examples Basic usage: local a = {1, 2, 3} local iterator = iter.array(a) -- A call to next() returns the next value... assert(1 == iter.next()) assert(2 == iter.next()) assert(3 == iter.next()) -- ... and then `nil` once it's over. assert(nil == iter.next())   "},{"title":"filter​","type":1,"pageTitle":"iter","url":"/iter/api/iter#filter","content":"&lt;/&gt; iter:filter(predicate: ( any, any ) → boolean) → iter Creates an iterator which uses a closure to determine if an element should be yielded. Given an element the closure must return true or false. The returned iterator will yield only the elements for which the closure returns true.  "},{"title":"forEach​","type":1,"pageTitle":"iter","url":"/iter/api/iter#forEach","content":"&lt;/&gt; iter:forEach(f: (...any) → ()) → () Calls a closure on each element of an iterator. This is equivalent to using a for loop on the iterator, although break and continue are not possible from a closure. It's generally more idiomatic to use a for loop, but for_each may be more legible when processing items at the end of longer iterator chains. #Examples Basic usage: tb.array({ 0, 1, 2 }) :map(function(x: number) return x * 100 end) :enumerate() :filter(function(i: number, x: number) return (i + x) % 3 == 0 end) :for_each(function(i: number, x: number) print(`{i}:{x}`) end)  "}]